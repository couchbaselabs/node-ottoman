"use strict";(self.webpackChunkottoman_documentation=self.webpackChunkottoman_documentation||[]).push([[2428],{3905:(t,e,n)=>{n.d(e,{Zo:()=>d,kt:()=>m});var a=n(7294);function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function r(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){o(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function s(t,e){if(null==t)return{};var n,a,o=function(t,e){if(null==t)return{};var n,a,o={},i=Object.keys(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||(o[n]=t[n]);return o}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(o[n]=t[n])}return o}var c=a.createContext({}),l=function(t){var e=a.useContext(c),n=e;return t&&(n="function"==typeof t?t(e):r(r({},e),t)),n},d=function(t){var e=l(t.components);return a.createElement(c.Provider,{value:e},t.children)},p={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},u=a.forwardRef((function(t,e){var n=t.components,o=t.mdxType,i=t.originalType,c=t.parentName,d=s(t,["components","mdxType","originalType","parentName"]),u=l(n),m=o,h=u["".concat(c,".").concat(m)]||u[m]||p[m]||i;return n?a.createElement(h,r(r({ref:e},d),{},{components:n})):a.createElement(h,r({ref:e},d))}));function m(t,e){var n=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var i=n.length,r=new Array(i);r[0]=u;var s={};for(var c in e)hasOwnProperty.call(e,c)&&(s[c]=e[c]);s.originalType=t,s.mdxType="string"==typeof t?t:o,r[1]=s;for(var l=2;l<i;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2996:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var a=n(7462),o=(n(7294),n(3905));const i={sidebar_position:0,title:"Transactions"},r=void 0,s={unversionedId:"advanced/transactions",id:"advanced/transactions",title:"Transactions",description:"A practical guide on using Couchbase Distributed ACID transactions in Ottoman.",source:"@site/docs/advanced/transactions.md",sourceDirName:"advanced",slug:"/advanced/transactions",permalink:"/docs/advanced/transactions",draft:!1,tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0,title:"Transactions"},sidebar:"tutorialSidebar",previous:{title:"Full Text Search",permalink:"/docs/advanced/fts"},next:{title:"How Ottoman Works",permalink:"/docs/advanced/how-ottoman-works"}},c={},l=[{value:"Creating a Transaction",id:"creating-a-transaction",level:2},{value:"Transaction Syntax",id:"transaction-syntax",level:3},{value:"Handle Error",id:"handle-error",level:3},{value:"Concurrent Operations",id:"concurrent-operations",level:3},{value:"Non-Transactional Writes",id:"non-transactional-writes",level:3},{value:"Configuration",id:"configuration",level:3},{value:"Ways of usage",id:"ways-of-usage",level:3},{value:"Examples",id:"examples",level:3},{value:"Save and retrieve a document inside a transaction, then check it was committed.",id:"save-and-retrieve-a-document-inside-a-transaction-then-check-it-was-committed",level:4},{value:"Bulk operations",id:"bulk-operations",level:4},{value:"Transactions with RefDoc Indexes",id:"transactions-with-refdoc-indexes",level:3},{value:"Additional Resources",id:"additional-resources",level:3}],d={toc:l};function p(t){let{components:e,...n}=t;return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"A practical guide on using Couchbase Distributed ACID transactions in Ottoman."),(0,o.kt)("p",null,"This guide will show you examples of how to perform multi-document ACID (atomic, consistent, isolated, and durable)\ndatabase transactions within your application."),(0,o.kt)("p",null,"Refer to the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.couchbase.com/nodejs-sdk/current/concept-docs/transactions.html"},"Transaction Concepts")," concept page for a high-level overview."),(0,o.kt)("admonition",{title:"Info",type:"info"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("strong",{parentName:"p"},"Notice:")," Transactions support was added in ottoman version ",(0,o.kt)("inlineCode",{parentName:"p"},"2.5.0"),". Please update to ",(0,o.kt)("inlineCode",{parentName:"p"},"2.5.0")," or later to use transactions."),(0,o.kt)("p",{parentName:"admonition"},"Ottoman's transactions implementation is intuitive and simple. If you already know how to use Ottoman, you can start working with transactions in no time."),(0,o.kt)("p",{parentName:"admonition"},"If not, please check the basics:"),(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/basic/ottoman"},"Ottoman")," object"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/basic/schema"},"Schema")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/basic/model"},"Model")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/basic/document"},"Document")))),(0,o.kt)("h2",{id:"creating-a-transaction"},"Creating a Transaction"),(0,o.kt)("p",null,"To create a transaction, an application must supply its logic inside an arrow function,\nincluding any conditional logic required. Once the arrow function has successfully run to completion,\nthe transaction will be automatically committed.\nIf at any point an error occurs, the transaction will rollback and the arrow function may run again."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"  const schema = new Schema({ name: String, age: Number });\n  const Swan = model('Swan', schema);\n  await start();\n  try {\n    await otttoman.$transactions(async (ctx: TransactionAttemptContext) => {\n      const odette = new Swan({ name: 'Odette', age: 30 });\n      await odette.save(false, { transactionContext: ctx });\n      // check the document was created in the transaction context\n      const doc = await Swan.findById(odette.id, { transactionContext: ctx });\n      console.log(doc);\n    });\n  } catch (error) {\n    if (error instanceof TransactionFailedError) {\n      console.error('Transaction did not reach commit point', error)\n    }\n\n    if (error instanceof TransactionCommitAmbiguousError) {\n      console.error('Transaction possibly committed', error)\n    }\n  }\n  // check the document was successfully committed\n  const doc = await Swan.findById(odette.id);\n  console.log(doc)\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"$transaction")," arrow function gets passed a ",(0,o.kt)("inlineCode",{parentName:"p"},"TransactionAttemptContext")," object--generally referred to as ",(0,o.kt)("inlineCode",{parentName:"p"},"ctx")," in these examples.\nSince the arrow function could be rerun multiple times, it is important that it does not contain any side effects.\nIn particular, you should never perform regular operations on a Collection, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"create()")," without using the ",(0,o.kt)("inlineCode",{parentName:"p"},"ctx"),", inside the arrow function.\nSuch operations may be performed multiple times, and will not be performed transactionally.\nInstead, you should perform these operations by using the ",(0,o.kt)("inlineCode",{parentName:"p"},"{ transactionContext: ctx }")," to pass the Transaction Context."),(0,o.kt)("p",null,"In the event that a transaction fails, your application could run into the following errors:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"TransactionCommitAmbiguousError")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"TransactionFailedError"))),(0,o.kt)("p",null,"Refer to ",(0,o.kt)("a",{parentName:"p",href:"https://docs.couchbase.com/nodejs-sdk/current/concept-docs/transactions-error-handling.html#transaction_errors"},"Error Handling")," for more details on these."),(0,o.kt)("p",null,"Methods that currently support transaction context:"),(0,o.kt)("p",null,"Ottoman:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"query"))),(0,o.kt)("p",null,"Model:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"count")," "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"find")," "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"findById"),"  "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"findOne"),"  "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"create"),"  "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"createMany"),"  "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"updateById"),"  "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"replaceById"),"  "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"updateMany"),"  "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"removeById"),"  "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"removeMany"),"  "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"findOneAndUpdate"))),(0,o.kt)("p",null,"Document:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"save")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"remove")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"populate"))),(0,o.kt)("h3",{id:"transaction-syntax"},"Transaction Syntax"),(0,o.kt)("p",null,"The syntax is pretty simple, just need to define the function to be run by ",(0,o.kt)("inlineCode",{parentName:"p"},"$transaction"),",\nthen you only need to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"ctx")," parameter as an option for the operations inside the ",(0,o.kt)("inlineCode",{parentName:"p"},"$transaction")," function."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"await otttoman.$transactions(async (ctx: TransactionAttemptContext) => {\n  const odette = Swan.create({ name: 'Odette', age: 30 }, { transactionContext: ctx });\n})\n")),(0,o.kt)("admonition",{title:"Tips",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"The only change you need to add is always to pass the ",(0,o.kt)("inlineCode",{parentName:"p"},"ctx")," in the option ",(0,o.kt)("inlineCode",{parentName:"p"},"transactionContext")," inside ",(0,o.kt)("inlineCode",{parentName:"p"},"$transaction")," function,\nthis way the operation will know you intend to use it as a transaction, use it as a rule of thumbs up and you will be fine.")),(0,o.kt)("admonition",{title:"Pitfall",type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"The ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"{ transactionContext: ctx }")," option ",(0,o.kt)("em",{parentName:"strong"},"must")," be passed as a parameter when inside of a ",(0,o.kt)("inlineCode",{parentName:"strong"},"$transaction")," function"),". Not passing this context will lead to unexpected results, and operations will not function as a transaction."),(0,o.kt)("p",{parentName:"admonition"},"Keep a sharp eye on it!")),(0,o.kt)("h3",{id:"handle-error"},"Handle Error"),(0,o.kt)("p",null,"While creating a transaction you always should wrap it inside a ",(0,o.kt)("inlineCode",{parentName:"p"},"try catch")," block and handle the exceptions."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"try {\n  await otttoman.$transactions(async (ctx: TransactionAttemptContext) => {\n    const odette = Swan.create({ name: 'Odette', age: 30 }, { transactionContext: ctx });\n  });\n} catch (error) {\n  if (error instanceof TransactionFailedError) {\n    console.error('Transaction did not reach commit point', error)\n  }\n\n  if (error instanceof TransactionCommitAmbiguousError) {\n    console.error('Transaction possibly committed', error)\n  }\n}\n")),(0,o.kt)("h3",{id:"concurrent-operations"},"Concurrent Operations"),(0,o.kt)("p",null,"The API allows operations to be performed concurrently inside a transaction, which can assist performance.\nThere are two rules the application needs to follow:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The first mutation must be performed alone, in serial. This is because the first mutation also triggers the creation of metadata for the transaction."),(0,o.kt)("li",{parentName:"ul"},"All concurrent operations must be allowed to complete fully, so the transaction can track which operations need to be rolled back in the event of failure. This means the application must 'swallow' the error, but record that an error occurred, and then at the end of the concurrent operations, if an error occurred, throw an error to cause the transaction to retry.")),(0,o.kt)("admonition",{title:"Note: Query Concurrency",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Only one query statement will be performed by the Query service at a time. Non-blocking mechanisms can be used to perform multiple concurrent query statements, but this may result internally in some added network traffic due to retries, and is unlikely to provide any increased performance.")),(0,o.kt)("h3",{id:"non-transactional-writes"},"Non-Transactional Writes"),(0,o.kt)("p",null,"To ensure key-value performance is not compromised, and to avoid conflicting writes, applications should never perform non-transactional writes concurrently with transactional ones, on the same document."),(0,o.kt)("p",null,"See ",(0,o.kt)("a",{parentName:"p",href:"https://docs.couchbase.com/nodejs-sdk/current/concept-docs/transactions.html#concurrency-with-non-transactional-writes"},"Concurrency with Non-Transactional Writes")," to learn more."),(0,o.kt)("h3",{id:"configuration"},"Configuration"),(0,o.kt)("p",null,"The default configuration should be appropriate for most use cases.\nTransactions can optionally be globally configured when configuring the Cluster.\nFor example, if you want to change the level of durability which that be attained,\nthis can be configured as part of the connect options:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Ottoman } from 'ottoman';\n\nconst ottoman = new Ottoman();\n\nconst main = async () => {\n  await ottoman.connect({\n    connectionString: 'couchbase://localhost',\n    bucketName: 'travel-sample',\n    username: 'admin',\n    password: 'password',\n    transactions: {\n      durabilityLevel: DurabilityLevel.PersistToMajority,\n    },\n  });\n}\n\nmain();\n")),(0,o.kt)("p",null,"The default configuration will perform all writes with the durability setting ",(0,o.kt)("inlineCode",{parentName:"p"},"Majority"),",\nensuring that each write is available in-memory on the majority of replicas before the transaction continues.\nThere are two higher durability settings available that will additionally wait for all mutations\nto be written to physical storage on either the active or the majority of replicas,\nbefore continuing. This further increases safety, at the cost of additional latency."),(0,o.kt)("admonition",{title:"Caution",type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"A level of ",(0,o.kt)("inlineCode",{parentName:"p"},"None")," is present but its use is discouraged and unsupported.\nIf durability is set to ",(0,o.kt)("inlineCode",{parentName:"p"},"None"),", then ACID compliance is not guaranteed.")),(0,o.kt)("h3",{id:"ways-of-usage"},"Ways of usage"),(0,o.kt)("p",null,"Inside the ",(0,o.kt)("inlineCode",{parentName:"p"},"$transaction")," function you can do almost everything you can do with Ottoman, for instance:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"K/V")," Operations"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"N1QL")," queries"),(0,o.kt)("li",{parentName:"ul"},"Combinations between ",(0,o.kt)("inlineCode",{parentName:"li"},"K/V")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"N1QL"))),(0,o.kt)("h3",{id:"examples"},"Examples"),(0,o.kt)("h4",{id:"save-and-retrieve-a-document-inside-a-transaction-then-check-it-was-committed"},"Save and retrieve a document inside a transaction, then check it was committed."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const schema = new Schema({ name: String, age: Number });\nconst Swan = model('Swan', schema);\nawait start();\ntry {\n  await otttoman.$transactions(async (ctx: TransactionAttemptContext) => {\n    const name = `Odette`;\n    const odette = new Swan({ name, age: 30 });\n    await odette.save(false, { transactionContext: ctx });\n    // check the document was created in the transaction context\n    const list = await Swan.find({ name: 'Odette' }, { transactionContext: ctx });\n  });\n} catch (e) {\n  // Error handling logic goes here.\n}\n// check the document was successfully committed\nconst list = await Swan.find({ name: 'Odette' }, { consistency: SearchConsistency.LOCAL });\n")),(0,o.kt)("h4",{id:"bulk-operations"},"Bulk operations"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const schema = new Schema({ name: String, age: Number });\nconst Duck = model('Duck', schema);\nawait start();\ntry {\n  await otttoman.$transactions(async (ctx: TransactionAttemptContext) => {\n    const daisy = `Daisy`;\n    const donald = `Donald`;\n    const daffy = `Daffy`;\n    // create 3 documents in the current context\n    await Duck.createMany(\n      [\n        { name: daffy, age: 84 },\n        { name: donald, age: 84 },\n        { name: daisy, age: 84 },\n      ],\n      { transactionContext: ctx },\n    );\n    \n    // execute a count query to check the 3 documents were created in the context\n    const duckCount = await Duck.count({}, { transactionContext: ctx });\n    console.log(duckCount)\n    \n    // rename the documents with age = 84 to Daisy\n    await Duck.updateMany({ age: 84 }, { name: daisy }, { transactionContext: ctx });\n    \n    // query the list of documents to check they were updated as expected\n    const list = await Duck.find({ age: 84 }, { transactionContext: ctx });\n    console.log(list.rows)\n  });\n} catch (e) {\n  // Error handling logic goes here.\n}\n\n// query the list of documents to check they were updated and committed\nconst list = await Duck.find({ age: 84 }, { consistency: SearchConsistency.LOCAL });\nconsole.log(list.rows)\n")),(0,o.kt)("h3",{id:"transactions-with-refdoc-indexes"},"Transactions with RefDoc Indexes"),(0,o.kt)("admonition",{title:"Pitfall",type:"danger"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("strong",{parentName:"p"},"RefDoc Indexes are not currently supported with transactions.")," Avoid accessing or mutating schemas that are indexed with a RefDoc index within a transaction. Doing so will lead to unexpected results, and operations will not function as a transaction.")),(0,o.kt)("p",null,"Any schema in your Ottoman project that is indexed with a ",(0,o.kt)("a",{parentName:"p",href:"/docs/basic/schema#refdoc"},"RefDoc index")," should ",(0,o.kt)("strong",{parentName:"p"},"not be accessed or mutated within a transaction.")," For example, if the ",(0,o.kt)("inlineCode",{parentName:"p"},"Swan")," schema is indexed with a RefDoc index, the following code will work, but the transaction will not be atomic:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"await otttoman.$transactions(async (ctx: TransactionAttemptContext) => {\n  const odette = Swan.create({ name: 'Odette', age: 30 }, { transactionContext: ctx });\n})\n")),(0,o.kt)("p",null,"It is acceptable to access ",(0,o.kt)("em",{parentName:"p"},"other")," schemas that are ",(0,o.kt)("strong",{parentName:"p"},"not")," indexed with a RefDoc index within a transaction. Ottoman will warn you if your project has ",(0,o.kt)("strong",{parentName:"p"},"any")," refdoc indexes when you attempt to use transactions, but it is up to you to ensure that you do not access or mutate these particular schemas within a transaction. "),(0,o.kt)("h3",{id:"additional-resources"},"Additional Resources"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Check the Couchbase Node.JS SDK ",(0,o.kt)("a",{parentName:"li",href:"https://docs.couchbase.com/nodejs-sdk/current/howtos/distributed-acid-transactions-from-the-sdk.html"},"transaction documentation"),"."),(0,o.kt)("li",{parentName:"ul"},"Learn more about ",(0,o.kt)("a",{parentName:"li",href:"https://docs.couchbase.com/nodejs-sdk/current/concept-docs/transactions.html"},"Distributed ACID Transactions"),"."),(0,o.kt)("li",{parentName:"ul"},"Check out the SDK ",(0,o.kt)("a",{parentName:"li",href:"https://docs.couchbase.com/sdk-api/couchbase-node-client/index.html"},"API Reference"),".")))}p.isMDXComponent=!0}}]);