"use strict";(self.webpackChunkottoman_documentation=self.webpackChunkottoman_documentation||[]).push([[6077],{314:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"basic/schema","title":"Schemas","description":"Schema maps to a Couchbase collection and defines the shape of the documents within that collection.","source":"@site/docs/basic/schema.md","sourceDirName":"basic","slug":"/basic/schema","permalink":"/docs/basic/schema","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Schemas"},"sidebar":"tutorialSidebar","previous":{"title":"Quickstart","permalink":"/docs/quick-start"},"next":{"title":"Models","permalink":"/docs/basic/model"}}');var t=a(4848),i=a(8453);const o={sidebar_position:2,title:"Schemas"},r="Schema",c={},d=[{value:"Defining Your Schema",id:"defining-your-schema",level:2},{value:"Allowed SchemaTypes",id:"allowed-schematypes",level:2},{value:"Custom SchemaTypes",id:"custom-schematypes",level:3},{value:"Schema Options",id:"schema-options",level:2},{value:"Option Timestamps",id:"option-timestamps",level:3},{value:"Generate UUID for a field",id:"generate-uuid-for-a-field",level:3},{value:"Creating a Model",id:"creating-a-model",level:2},{value:"Instance Methods",id:"instance-methods",level:2},{value:"Statics",id:"statics",level:2},{value:"Indexes",id:"indexes",level:2},{value:"Index Types",id:"index-types",level:2},{value:"N1QL Query Language",id:"n1ql-query-language",level:3},{value:"RefDoc",id:"refdoc",level:3},{value:"View",id:"view",level:3},{value:"Hooks",id:"hooks",level:2},{value:"Available Hooks",id:"available-hooks",level:3},{value:"Register Hooks with <code>pre</code>",id:"register-hooks-with-pre",level:3},{value:"Hooks Use Cases",id:"hooks-use-cases",level:3},{value:"Errors in Pre Hooks",id:"errors-in-pre-hooks",level:3},{value:"Post Hooks",id:"post-hooks",level:3},{value:"Define Hooks Before Compiling Models",id:"define-hooks-before-compiling-models",level:3},{value:"Save/Validate Hooks",id:"savevalidate-hooks",level:3},{value:"Plugins",id:"plugins",level:2},{value:"Plugin Example",id:"plugin-example",level:3},{value:"Global Plugins",id:"global-plugins",level:3},{value:"Strict Mode",id:"strict-mode",level:2},{value:"Schema Types Immutable Option",id:"schema-types-immutable-option",level:2},{value:"Immutable with strategy <code>true</code> <em><strong>(default)</strong></em>",id:"immutable-with-strategy-true-default",level:3},{value:"Immutable with strategy <code>false</code>",id:"immutable-with-strategy-false",level:3},{value:"Immutable with strategy <code>THROW</code>",id:"immutable-with-strategy-throw",level:3},{value:"Schema Helpful Methods",id:"schema-helpful-methods",level:2},{value:"Cast Method",id:"cast-method",level:3},{value:"Cast Method Options",id:"cast-method-options",level:4},{value:"Validate method",id:"validate-method",level:3},{value:"Validate Method Options",id:"validate-method-options",level:4},{value:"Extend Schemas",id:"extend-schemas",level:2},{value:"Add Method",id:"add-method",level:3},{value:"Next Up",id:"next-up",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"schema",children:"Schema"})}),"\n",(0,t.jsx)(n.p,{children:"Schema maps to a Couchbase collection and defines the shape of the documents within that collection."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"How to Use",src:a(7944).A+"",width:"997",height:"681"})}),"\n",(0,t.jsx)(n.h2,{id:"defining-your-schema",children:"Defining Your Schema"}),"\n",(0,t.jsx)(n.p,{children:"Everything in Ottoman starts with a Schema."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { Schema } from 'ottoman';\n\nconst blogSchema = new Schema({\n  title: { type: String, required: true },\n  author: String, // String is shorthand for { type: String }\n  authorNative: Schema.Types.String,\n  body: String,\n  comments: [{ body: String, date: Date }],\n  date: { type: Date, default: Date.now },\n  hidden: Boolean,\n  status: { type: String, enum: ['Close', 'Open', 'Review'] },\n  meta: {\n    votes: { type: Number, min: 0, max: 5 },\n    favs: Number,\n  },\n  mixedObject: Object,\n  mixedNative: Schema.Types.Mixed,\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["For more information about options, please ",(0,t.jsx)(n.a,{href:"/docs/basic/schema.html#allowed-schematypes",children:"review the types"})]}),"\n",(0,t.jsxs)(n.p,{children:["Each key in our code ",(0,t.jsx)(n.code,{children:"blogSchema"})," defines a property in our documents which will be cast to its associated ",(0,t.jsx)(n.a,{href:"#allowed-schematypes",children:"SchemaType"}),". For example, we've defined a property ",(0,t.jsx)(n.code,{children:"title"})," that will be cast to the ",(0,t.jsx)(n.a,{href:"/docs/api/classes/stringtype.html",children:"String"})," SchemaType and property ",(0,t.jsx)(n.code,{children:"date"})," which will be cast to a ",(0,t.jsx)(n.a,{href:"/docs/api/classes/datetype.html",children:"Date"})," SchemaType."]}),"\n",(0,t.jsxs)(n.p,{children:["Please note above that if a property only requires a type, it can be specified using a shorthand notation (contrast the ",(0,t.jsx)(n.code,{children:"title"})," property above with the ",(0,t.jsx)(n.code,{children:"date"})," property)."]}),"\n",(0,t.jsxs)(n.p,{children:["Keys may also be assigned to nested objects containing further key/type definitions like the ",(0,t.jsx)(n.code,{children:"meta"})," property above.\nThis will happen whenever a key's value is a POJO that lacks a bona fide ",(0,t.jsx)(n.code,{children:"type"})," property.\nIn these cases, only the leaves in a tree are given actual paths in the schema (like ",(0,t.jsx)(n.code,{children:"meta.votes"})," and ",(0,t.jsx)(n.code,{children:"meta.favs"})," above), and the branches do not have actual paths.\nThe ",(0,t.jsx)(n.code,{children:"meta"})," above cannot have its own validation as a side-effect of this. If validation is needed up the tree, a path needs to be created up the tree."]}),"\n",(0,t.jsx)(n.h2,{id:"allowed-schematypes",children:"Allowed SchemaTypes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/api/classes/stringtype",children:"String"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/api/classes/numbertype",children:"Number"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/api/classes/booleantype",children:"Boolean"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/api/classes/datetype",children:"Date"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/api/classes/arraytype",children:"Array"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/api/classes/embedtype",children:"Embed"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/api/classes/referencetype",children:"Reference"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/api/classes/mixedtype",children:"Mixed"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.em,{children:(0,t.jsx)(n.a,{href:"/docs/basic/schema#custom-schematypes",children:"Custom"})})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Schemas not only define the structure of your document and casting of properties, they also define document ",(0,t.jsx)(n.a,{href:"#instance-methods",children:"instance methods"}),", ",(0,t.jsx)(n.a,{href:"#statics",children:"static Model methods"}),",\n",(0,t.jsx)(n.a,{href:"#indexes",children:"compound indexes"}),", ",(0,t.jsx)(n.a,{href:"#plugins",children:"plugins"}),", and document lifecycle ",(0,t.jsx)(n.a,{href:"#hooks",children:"hooks"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"custom-schematypes",children:"Custom SchemaTypes"}),"\n",(0,t.jsx)(n.p,{children:"Ottoman supports custom types. Before you reach for a custom type, however, know that a custom type is overkill for most use cases."}),"\n",(0,t.jsxs)(n.p,{children:["Let's take a look at an example of a basic schema type: a 1-byte integer. To create a new schema type, you need to inherit from ",(0,t.jsx)(n.code,{children:"IOttomanType"})," and add the corresponding ",(0,t.jsx)(n.code,{children:"registerType"}),". The only methods you need to implement are ",(0,t.jsx)(n.a,{href:"/docs/basic/schema.html#cast-method",children:"cast()"})," and ",(0,t.jsx)(n.a,{href:"/docs/basic/schema.html#validate-method",children:"validate()"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class Int8 extends IOttomanType {\n  constructor(name: string) {\n    super(name, 'Int8');\n  }\n\n  cast(value: unknown): unknown {\n    const castedValue = Number(value);\n    return isNaN(castedValue)\n      ? checkCastStrategy(value, CAST_STRATEGY.THROW, this)\n      : castedValue;\n  }\n\n  validate(value: unknown): unknown {\n    let int8Value = Number(value);\n    if (isNaN(int8Value)) {\n      throw new ValidationError(`Int8: ${value} is not a number`);\n    }\n    int8Value = Math.round(int8Value);\n    if (int8Value < -0x80 || int8Value > 0x7f) {\n      throw new ValidationError(`Int8: ${value} is outside of the range of valid 8-bit ints`);\n    }\n    return int8Value;\n  }\n}\n\n// Don't forget to add `Int8` to the type registry\nregisterType(Int8.name, (fieldName) => new Int8(fieldName));\n\n// Define schema and model\nconst CustomTypeSchema = new Schema({ test: Int8 });\nconst CustomTypeModel = model('CustomTypeExample', CustomTypeSchema);\n\nCustomTypeSchema instanceof Schema; // true\nCustomTypeSchema.path('test') instanceof Int8; // true\n\nconst value = new CustomTypeModel({ test: 0x6f });\nvalue._validate().test; // 111\n\nconst bigger = new CustomTypeModel({ test: 0x8f });\nbigger._validate(); // ValidationError: Int8: 143 is outside of the range of valid 8-bit ints\n\nconst invalid = new CustomTypeModel({ test: 'invalid test value' });\ninvalid._validate(); // ValidationError: Property 'test' must be of type 'Int8'\n\n"})}),"\n",(0,t.jsx)(n.h2,{id:"schema-options",children:"Schema Options"}),"\n",(0,t.jsx)(n.p,{children:"Schemas have a few configurable options which can be passed to the constructor:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"new Schema({...}, options);\n"})}),"\n",(0,t.jsx)(n.p,{children:"The availables options are:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export interface SchemaOptions {\n  strict?: boolean;\n  preHooks?: Hook;\n  postHooks?: Hook;\n  timestamps?: boolean | SchemaTimestampsConfig;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"option-timestamps",children:"Option Timestamps"}),"\n",(0,t.jsxs)(n.p,{children:["The timestamps option tells ",(0,t.jsx)(n.code,{children:"Ottoman"})," to assign ",(0,t.jsx)(n.code,{children:"createdAt"})," and ",(0,t.jsx)(n.code,{children:"updatedAt"})," fields to your schema. The type assigned is ",(0,t.jsx)(n.code,{children:"Date"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["By default, the names of the fields are ",(0,t.jsx)(n.code,{children:"createdAt"})," and ",(0,t.jsx)(n.code,{children:"updatedAt"}),". Customize the field names by setting ",(0,t.jsx)(n.code,{children:"timestamps.createdAt"})," and ",(0,t.jsx)(n.code,{children:"timestamps.updatedAt"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Basic example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const travelSchema = new Schema({..}, { timestamps: true });\nconst Travel = model('Travel', thingSchema);\nconst travel = new Travel();\nawait travel.save(); // `createdAt` & `updatedAt` will be included\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Customize ",(0,t.jsx)(n.code,{children:"createdAt"})," to ",(0,t.jsx)(n.code,{children:"created_at"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const travelSchema = new Schema({..}, { timestamps: { createdAt: 'created_at' } });\nconst Travel = model('Travel', thingSchema);\nconst travel = new Travel();\nawait travel.save(); // `created_at` & `updatedAt` will be included\n"})}),"\n",(0,t.jsxs)(n.p,{children:["By default, Ottoman uses ",(0,t.jsx)(n.code,{children:"new Date()"})," to get the current time. If you want to overwrite the function Ottoman uses to get the current time, you can set the ",(0,t.jsx)(n.code,{children:"timestamps.currentTime"})," option.\nOttoman will call the ",(0,t.jsx)(n.code,{children:"timestamps.currentTime"})," function whenever it needs to get the current time."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const schema = Schema({\n  createdAt: Number,\n  updatedAt: Number,\n  name: String\n}, {\n  // Make Ottoman use Unix time (seconds since Jan 1, 1970)\n  timestamps: { currentTime: () => Math.floor(Date.now() / 1000) }\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"generate-uuid-for-a-field",children:"Generate UUID for a field"}),"\n",(0,t.jsx)(n.p,{children:"Sometimes we want to provide a unique value to a field.\nOttoman provides an easy way to generate a UUID value for a given field by setting the below configuration in the schema."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const schema = new Schema(\n  { customId: {type: String, auto: 'uuid'} }\n);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Now, every time you create a document, the field ",(0,t.jsx)(n.code,{children:"customId"})," will have a unique value (generated by UUID)."]}),"\n",(0,t.jsx)(n.p,{children:"For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "customId": "0057896b-18a2-4e71-b364-76c8f78979f"\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"creating-a-model",children:"Creating a Model"}),"\n",(0,t.jsxs)(n.p,{children:["To use our schema definition, we need to convert our ",(0,t.jsx)(n.code,{children:"blogSchema"})," into a ",(0,t.jsx)(n.a,{href:"/docs/basic/model.html",children:"Model"})," we can work with. To do so, we pass it into ",(0,t.jsx)(n.code,{children:"model(modelName, schema)"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const Blog = model('Blog', blogSchema);\n// ready to go!\n"})}),"\n",(0,t.jsx)(n.h2,{id:"instance-methods",children:"Instance Methods"}),"\n",(0,t.jsxs)(n.p,{children:["Instances of ",(0,t.jsx)(n.code,{children:"Models"})," are ",(0,t.jsx)(n.a,{href:"/docs/basic/document",children:"documents"}),". Documents have many of their own ",(0,t.jsx)(n.a,{href:"/docs/api/classes/document.html",children:"built-in instance methods"}),". We may also define our own custom document instance methods."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { connect, Schema } from 'ottoman';\nconst main = async () => {\n  // connecting\n  const connection = await connect('couchbase://localhost/travel-sample@admin:password');\n\n  // define a schema\n  const animalSchema = new Schema({ name: String, type: String });\n\n  // assign a function to the \"methods\" object of our animalSchema\n  animalSchema.methods.findSimilarTypes = function () {\n    return connection.getModel('Animal').find({ type: this.type });\n  };\n}\n\nmain();\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Now all of our ",(0,t.jsx)(n.code,{children:"animal"})," instances have a ",(0,t.jsx)(n.code,{children:"findSimilarTypes"})," method available to them."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const Animal = model('Animal', animalSchema);\nconst dog = new Animal({ type: 'dog' });\n\nconst dogs = await dog.findSimilarTypes();\nconsole.log(dogs);\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Overwriting a default Ottoman document method may lead to unpredictable results."}),"\n",(0,t.jsxs)(n.li,{children:["The example above uses the ",(0,t.jsx)(n.code,{children:"Schema.methods"})," object directly to save an instance method."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{title:"Note",type:"danger",children:(0,t.jsxs)(n.p,{children:["Do ",(0,t.jsx)(n.strong,{children:"not"})," declare ",(0,t.jsx)(n.em,{children:"methods"})," using ES6 arrow functions (",(0,t.jsx)(n.code,{children:"=>"}),"). Arrow functions ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions",children:"explicitly prevent binding"})," ",(0,t.jsx)(n.code,{children:"this"}),", so your method will ",(0,t.jsx)(n.strong,{children:"not"})," have access to the document, and the above examples will not work."]})}),"\n",(0,t.jsx)(n.h2,{id:"statics",children:"Statics"}),"\n",(0,t.jsx)(n.p,{children:"You can also add static functions to your model."}),"\n",(0,t.jsxs)(n.p,{children:["Add a function property to ",(0,t.jsx)(n.code,{children:"schema.statics"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Assign a function to the \"statics\" object of our animalSchema\nanimalSchema.statics.findByName = function (name) {\n  return this.find({ name: name });\n};\n\nconst Animal = model('Animal', animalSchema);\nlet animals = await Animal.findByName('fido');\n"})}),"\n",(0,t.jsx)(n.admonition,{title:"Note",type:"danger",children:(0,t.jsxs)(n.p,{children:["Do ",(0,t.jsx)(n.strong,{children:"not"})," declare ",(0,t.jsx)(n.em,{children:"statics"})," using ES6 arrow functions (",(0,t.jsx)(n.code,{children:"=>"}),"). Arrow functions ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions",children:"explicitly prevent binding"})," ",(0,t.jsx)(n.code,{children:"this"}),", so the above examples will ",(0,t.jsx)(n.strong,{children:"not"})," work because of the value of ",(0,t.jsx)(n.code,{children:"this"}),"."]})}),"\n",(0,t.jsx)(n.h2,{id:"indexes",children:"Indexes"}),"\n",(0,t.jsx)(n.p,{children:"You can specify several indexes on a model. There are different kinds of indexes, each with its own benefits and restrictions."}),"\n",(0,t.jsxs)(n.p,{children:["To specify indexes on a ",(0,t.jsx)(n.a,{href:"/docs/basic/schema",children:"Schema"}),", use the index key on the schema:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { Schema } from 'ottoman';\n\nconst schema = new Schema({\n  email: String,\n  name: {\n    first: String,\n    last: String,\n    full: String,\n  },\n});\n\nschema.index.findByEmail = {\n  by: 'email',\n  type: 'refdoc',\n};\n\nschema.index.findByFirstName = {\n  by: 'name.first',\n  type: 'view',\n};\n\nschema.index.findByLastName = {\n  by: 'name.last',\n  type: 'n1ql',\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To ensure that server is working, you must call the ",(0,t.jsx)(n.code,{children:"start"})," method. This method will internally generate a list of indexes and scopes, collections (if you have the developer preview active) which will be used with the most optimal configuration for them and will build the structures that might be missing on the server. This method must be called after all models are defined, and it is a good idea to call this only when needed rather than any time your server is started."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const { connect, model, start, close } = require('ottoman');\n\nasync function createUser() {\n  await connect('couchbase://localhost/travel-sample@admin:password');\n  \n  const User = model('User', { name: String });\n  const user = new User({ name: 'Jane Doe' });\n\n  try {\n    await start();\n\n    console.log(\"Ottoman is ready!\")\n    const newUser = await user.save();\n\n    await close();\n    console.log(`User '${ newUser.name }' successfully created`);\n  } catch (e) {\n    console.log(`ERROR: ${ e.message }`);\n  }\n}\n\ncreateUser();\n"})}),"\n",(0,t.jsx)(n.p,{children:"You should see results similar to the following:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"Ottoman is ready!\nUser 'Jane Doe' successfully created\n"})}),"\n",(0,t.jsx)(n.h2,{id:"index-types",children:"Index Types"}),"\n",(0,t.jsxs)(n.p,{children:["Below are some quick notes on the types of indexes available, and their pros and cons. For a more in-depth discussion, consider reading ",(0,t.jsx)(n.a,{href:"https://blog.couchbase.com/determine-data-access-in-couchbase/",children:"Couchbasics: How Functional and Performance Needs Determine Data Access in Couchbase"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"n1ql-query-language",children:"N1QL Query Language"}),"\n",(0,t.jsxs)(n.p,{children:["These indexes are the default and use the Couchbase Server's SQL-like query language, ",(0,t.jsx)(n.a,{href:"https://docs.couchbase.com/server/current/n1ql/query.html",children:"N1QL"}),". When ",(0,t.jsx)(n.code,{children:"start"})," or ",(0,t.jsx)(n.code,{children:"ensureIndexes"})," functions are executed, Ottoman automatically creates several secondary indexes so that the models can make queries to the database. These indexes are more performant than views in many cases and are significantly more flexible, allowing even un-indexed searches."]}),"\n",(0,t.jsxs)(n.p,{children:["N1QL indexes in Ottoman use ",(0,t.jsx)(n.a,{href:"https://docs.couchbase.com/server/current/learn/services-and-indexes/indexes/global-secondary-indexes.html",children:"Couchbase GSIs"}),". If you need speed, and the flexibility of queries, this is the way to go."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const UserSchema = new Schema({\n  name: String,\n  email: String,\n  card: {\n    cardNumber: String,\n    zipCode: String,\n  },\n  roles: [{ name: String }],\n});\n\n// N1QL index declaration\nUserSchema.index.findN1qlByNameandEmail = {\n  by: ['name', 'email'],\n  options: { limit: 4, select: 'name, email' },\n  type: 'n1ql',\n};\n\n// Model declaration\nconst User = model('User', UserSchema);\n\n// Some data to test\nconst userData = {\n  name: `index`,\n  email: 'index@email.com',\n  card: { cardNumber: '424242425252', zipCode: '42424' },\n  roles: [{ name: 'admin' }],\n};\n\n// Create new user instance\nconst user = new User(userData);\n// Save data\nawait user.save();\n\n// Call findN1qlByNameandEmail index\nconst usersN1ql = await User.findN1qlByNameandEmail([userData.name, userData.email]);\nconsole.log(usersN1ql.rows);\n\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:'// Output!!!\n[\n  {\n    "_type": "User",\n    "email": "index@email.com",\n    "name": "index"\n  }\n]\n'})}),"\n",(0,t.jsxs)(n.admonition,{title:"Not Recommended",type:"warning",children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"ensureIndex"})," is nice for development, but it's recommended this behavior be disabled in production since index creation can cause a significant performance impact.\nDisable the behavior by not executing ",(0,t.jsx)(n.code,{children:"ensureIndex"})," function. (for example you can use node env variable to know when you are in development mode [process.ENV.development])"]}),(0,t.jsxs)(n.p,{children:["Notice: the ",(0,t.jsx)(n.code,{children:"start"})," function should be disabled too, owing to its use of ",(0,t.jsx)(n.code,{children:"ensureIndexes"})," internally."]})]}),"\n",(0,t.jsx)(n.h3,{id:"refdoc",children:"RefDoc"}),"\n",(0,t.jsx)(n.p,{children:"These indexes are the most performant, but the least flexible. They allow only a single document to occupy any particular value and do direct key-value lookups using a referential document to identify a matching document in Couchbase."}),"\n",(0,t.jsx)(n.p,{children:"In short, if you need to look up a document by a single value of a single attribute quickly (e.g. key lookups), this is the way to go. But you cannot combine multiple refdoc indexes to speed up finding something like \"all customers with the first name of 'John' and last name of 'Smith'\"."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const UserSchema = new Schema({\n  name: String,\n  email: String,\n  card: {\n    cardNumber: String,\n    zipCode: String,\n  },\n  roles: [{ name: String }],\n});\n\n// Refdoc index declaration\nUserSchema.index.findRefName = { by: 'name', type: 'refdoc' };\n\n// Model declaration\nconst User = model('User', UserSchema);\n\n// Some data to test\nconst userData = {\n  name: `index`,\n  email: 'index@email.com',\n  card: { cardNumber: '424242425252', zipCode: '42424' },\n  roles: [{ name: 'admin' }],\n};\n\n// Create new user instance\nconst user = new User(userData);\n// Save data\nawait user.save();\n\n// Call findRefName index\nconst userRefdoc = await User.findRefName(userData.name);\nconsole.log(userRefdoc);\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:'{\n  "name": "index",\n  "email": "index@email.com",\n  "card": {\n    "cardNumber": "424242425252",\n    "zipCode": "42424"\n  },\n  "roles": [\n    {\n      "name": "admin"\n    }\n  ],\n  "id": "66c2d0dd-76ab-4b91-83b4-353893e3ede3",\n  "_type": "User"\n}\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"danger",children:(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"RefDoc Indexes"})," are not currently supported with transactions. If you plan to use transactions, see ",(0,t.jsx)(n.a,{href:"/docs/advanced/transactions#transactions-with-refdoc-indexes",children:"Ottoman Transactions"})," for more information."]})}),"\n",(0,t.jsxs)(n.admonition,{type:"caution",children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"RefDoc Indexes"})," are not managed by Couchbase but strictly by Ottoman. It does not guarantee consistency if the keys that are a part of these indexes are updated by an external operation, like N1QL for example."]}),(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.em,{children:"Please use with caution!"})})})]}),"\n",(0,t.jsx)(n.h3,{id:"view",children:"View"}),"\n",(0,t.jsx)(n.admonition,{title:"Deprecated",type:"warning",children:(0,t.jsx)(n.p,{children:"View indexes were deprecated in Ottoman v2 and will be removed in the next major version of the package."})}),"\n",(0,t.jsxs)(n.p,{children:["This type of index is always available once ",(0,t.jsx)(n.code,{children:"ensureIndexes"})," is called and will work with any Couchbase Server version."]}),"\n",(0,t.jsx)(n.p,{children:"Because views use map-reduce, certain types of queries can be faster as the query can be parallelized over all nodes in the cluster, with each node returning only partial results. One of the cons of views is that they are eventually consistent by default, and incur a performance penalty if you want consistency in the result."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const UserSchema = new Schema({\n  name: String,\n  email: String,\n  card: {\n    cardNumber: String,\n    zipCode: String,\n  },\n  roles: [{ name: String }],\n});\n\n// View index declaration\nUserSchema.index.findByName = { by: 'name', type: 'view' };\n\n// Model declaration\nconst User = model('User', UserSchema);\n\n// Some data to test\nconst userData = {\n  name: `index`,\n  email: 'index@email.com',\n  card: { cardNumber: '424242425252', zipCode: '42424' },\n  roles: [{ name: 'admin' }],\n};\n\n// Create new user instance\nconst user = new User(userData);\n// Save data\nawait user.save();\n\n// Call findByName index\nconst viewIndexOptions = new ViewIndexOptions({ limit: 1 });\nconst usersView = await User.findByName(userData.name, viewIndexOptions);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"hooks",children:"Hooks"}),"\n",(0,t.jsx)(n.p,{children:"Hooks are functions that are passed control during the execution of asynchronous functions. Hooks are specified at the schema level and are useful for writing plugins."}),"\n",(0,t.jsx)(n.h3,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"validate"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"save"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"update"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"remove"})}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"register-hooks-with-pre",children:["Register Hooks with ",(0,t.jsx)(n.code,{children:"pre"})]}),"\n",(0,t.jsx)(n.p,{children:"Pre functions are executed one after another, for each hook registered."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { Schema } from 'ottoman';\n\nconst schema = new Schema(...);\nschema.pre('save', function (document) {\n  // do stuff\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"You can use a function that returns a promise. In particular, you can use async/await."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"schema.pre('save', function () {\n  return doStuff().then(() => doMoreStuff());\n});\n\n// Or, in Node.js >= 7.6.0:\nschema.pre('save', async function () {\n  await doStuff();\n  await doMoreStuff();\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"hooks-use-cases",children:"Hooks Use Cases"}),"\n",(0,t.jsx)(n.p,{children:"Hooks are useful for atomizing model logic, such as:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Complex validation;"}),"\n",(0,t.jsx)(n.li,{children:"Removing dependent documents (removing a user removes all his blogposts);"}),"\n",(0,t.jsx)(n.li,{children:"Asynchronous defaults;"}),"\n",(0,t.jsx)(n.li,{children:"Asynchronous tasks that a certain action triggers."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"errors-in-pre-hooks",children:"Errors in Pre Hooks"}),"\n",(0,t.jsx)(n.p,{children:"If any pre hook errors out, Ottoman will not execute subsequent hooks or the hooked function."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"schema.pre('save', function () {\n  // You can also return a promise that rejects\n  return new Promise((resolve, reject) => {\n    reject(new Error('something went wrong'));\n  });\n});\n\nschema.pre('save', function () {\n  // You can also throw a synchronous error\n  throw new Error('something went wrong');\n});\n\nschema.pre('save', async function () {\n  await Promise.resolve();\n  // You can also throw an error in an `async` function\n  throw new Error('something went wrong');\n});\n\n// later...\n\n// Changes will not be persisted to Couchbase Server because a pre hook errored out\ntry {\n  await myDoc.save();\n} catch (e) {\n  console.log(e.message); // something went wrong\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"post-hooks",children:"Post Hooks"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"post"})," middleware is executed after the hooked method and all of its pre hooks have been completed."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"schema.post('validate', function (doc) {\n  console.log('%s has been validated (but not saved yet)', doc.id);\n});\nschema.post('save', function (doc) {\n  console.log('%s has been saved', doc.id);\n});\nschema.post('remove', function (doc) {\n  console.log('%s has been removed', doc.id);\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"define-hooks-before-compiling-models",children:"Define Hooks Before Compiling Models"}),"\n",(0,t.jsxs)(n.p,{children:["Calling ",(0,t.jsx)(n.code,{children:"pre()"})," or ",(0,t.jsx)(n.code,{children:"post()"})," after compiling a model does not work in Ottoman in general. For example, the below ",(0,t.jsx)(n.code,{children:"pre('save')"})," hook will not fire."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const schema = new Schema({ name: String });\n\n// Compile a model from the schema\nconst User = model('User', schema);\n\n// Ottoman will **not** call the middleware function, because\n// this hook was defined after the model was compiled\nschema.pre('save', () => console.log('Hello from pre save'));\n\nnew User({ name: 'test' }).save();\n"})}),"\n",(0,t.jsx)(n.h3,{id:"savevalidate-hooks",children:"Save/Validate Hooks"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"save()"})," function triggers ",(0,t.jsx)(n.code,{children:"validate()"})," hooks, because Ottoman has a built-in ",(0,t.jsx)(n.code,{children:"pre('save')"})," hook that calls ",(0,t.jsx)(n.code,{children:"validate()"}),". This means that all ",(0,t.jsx)(n.code,{children:"pre('validate')"})," and ",(0,t.jsx)(n.code,{children:"post('validate')"})," hooks get called before any ",(0,t.jsx)(n.code,{children:"pre('save')"})," hooks. The ",(0,t.jsx)(n.code,{children:"updateById()"})," function have the same behavior."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"schema.pre('validate', function () {\n  console.log('this gets printed first');\n});\nschema.post('validate', function () {\n  console.log('this gets printed second');\n});\nschema.pre('save', function () {\n  console.log('this gets printed third');\n});\nschema.post('save', function () {\n  console.log('this gets printed fourth');\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"plugins",children:"Plugins"}),"\n",(0,t.jsx)(n.p,{children:"Schemas are pluggable, that is, they allow for applying pre-packaged capabilities to extend their functionality. This is a very powerful feature."}),"\n",(0,t.jsx)(n.h3,{id:"plugin-example",children:"Plugin Example"}),"\n",(0,t.jsxs)(n.p,{children:["Plugins are a tool for reusing logic in multiple schemas. Suppose you have several models in your database and want to add a function to log all doc before save. Just create a plugin once and apply it to each Schema using the ",(0,t.jsx)(n.code,{children:"plugin"})," function:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const pluginLog = (schema) => {\n  schema.pre('save', function (doc) {\n    console.log(doc)\n  });\n};\n\nconst UserSchema = new Schema({\n  isActive: Boolean,\n  name: String\n});\n\nUserSchema.plugin(pluginLog)\n\nconst UserModel = model('User', UserSchema);\n\nconst user = new UserModel(...);\n// Pre save hooks will be executed and it will print the document just before persisting to Couchbase Server\nawait user.save();\n"})}),"\n",(0,t.jsx)(n.h3,{id:"global-plugins",children:"Global Plugins"}),"\n",(0,t.jsxs)(n.p,{children:["Want to register a plugin for all schemas? The Ottoman ",(0,t.jsx)(n.code,{children:"registerGlobalPlugin"})," function registers a plugin for every schema. For example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { registerGlobalPlugin } from 'ottoman';\n\nconst pluginLog = (schema) => {\n  schema.pre('save', function (doc) {\n    console.log(doc)\n  });\n};\n\nregisterGlobalPlugin(pluginLog);\n\nconst UserSchema = new Schema({\n  isActive: Boolean,\n  name: String\n});\n\nconst UserModel = model('User', UserSchema);\n\nconst user = new UserModel(...);\n// Pre save hooks will be executed and it will print the document just before persisting to Couchbase Server\nawait user.save();\n"})}),"\n",(0,t.jsx)(n.h2,{id:"strict-mode",children:"Strict Mode"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"strict"})," option (enabled by default) ensures that values passed to our model constructor that were not specified in our schema do not get saved to the database."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const userSchema = new Schema({ ... })\nconst User = model('User', userSchema);\nconst user = new User({ iAmNotInTheSchema: true });\nuser.save(); // iAmNotInTheSchema is not saved to the db\n\n// set to false..\nconst userSchema = new Schema({ ... }, { strict: false });\nconst user = new User({ iAmNotInTheSchema: true });\nuser.save(); // iAmNotInTheSchema is now saved to the db!\n"})}),"\n",(0,t.jsx)(n.p,{children:"This value can be overridden at the model instance level by passing as second argument:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const User = model('User', userSchema);\nconst user = new User(doc, { strict: true }); // enables strict mode\nconst user = new User(doc, { strict: false }); // disables strict mode\n"})}),"\n",(0,t.jsx)(n.h2,{id:"schema-types-immutable-option",children:"Schema Types Immutable Option"}),"\n",(0,t.jsxs)(n.p,{children:["Defines this path as ",(0,t.jsx)(n.code,{children:"immutable"}),". Ottoman prevents you from changing ",(0,t.jsx)(n.code,{children:"immutable"})," paths allowing, you to safely write untrusted data to Couchbase without any additional validation."]}),"\n",(0,t.jsxs)(n.p,{children:["With update functions Ottoman also strips updates to ",(0,t.jsx)(n.code,{children:"immutable"})," properties from ",(0,t.jsx)(n.a,{href:"/docs/api/interfaces/imodel.html#updatebyid",children:"updateById()"}),", ",(0,t.jsx)(n.a,{href:"/docs/api/interfaces/imodel.html#updatemany",children:"updateMany()"}),", ",(0,t.jsx)(n.a,{href:"/docs/api/interfaces/imodel.html#replacebyid",children:"replaceById()"})," and ",(0,t.jsx)(n.a,{href:"/docs/api/interfaces/imodel.html#findoneandupdate",children:"findOneAndUpdate()"}),". Your update will succeed if you try to overwrite an ",(0,t.jsx)(n.code,{children:"immutable"})," property, Ottoman will just strip out the ",(0,t.jsx)(n.code,{children:"immutable"})," property."]}),"\n",(0,t.jsxs)(n.p,{children:["Let's see this option in action using ",(0,t.jsx)(n.code,{children:"findOneAndUpdate"})," on ",(0,t.jsx)(n.code,{children:"immutable"})," properties:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// Define base data\nconst cardData = {\n  cardNumber: '5678 5678 5678 5678',\n  zipCode: '56789',\n};\n\nconst cardDataUpdate = {\n  cardNumber: '4321 4321 4321 4321',\n  zipCode: '43210',\n};\n\n// Define schemas\nconst CardSchema = new Schema({\n  cardNumber: { type: String, immutable: true },\n  zipCode: String,\n});\n\n// Create model\nconst Card = model('Card', CardSchema);\n\n// Start Ottoman instance\nconst ottoman = getDefaultInstance();\nawait ottoman.start();\n\n// Initialize data\nconst { id } = await Card.create(cardData);\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"immutable-with-strategy-true-default",children:["Immutable with strategy ",(0,t.jsx)(n.code,{children:"true"})," ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"(default)"})})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"await Card.findOneAndUpdate(\n  { cardNumber: { $like: '%5678 5678 5678 5678%' } }, cardDataUpdate,\n  { new: true, strict: true }\n);\nconst result = await Card.findById(id);\nconsole.log(result);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Since ",(0,t.jsx)(n.code,{children:"cardNumber"})," is immutable, Ottoman ignores the update to ",(0,t.jsx)(n.code,{children:"cardNumber"})," and only ",(0,t.jsx)(n.code,{children:"zipCode"})," changed:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:"{\n  cardNumber: '5678 5678 5678 5678',\n  zipCode: '43210'\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"immutable-with-strategy-false",children:["Immutable with strategy ",(0,t.jsx)(n.code,{children:"false"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"await Card.findOneAndUpdate(\n  { cardNumber: { $like: '%5678 5678 5678 5678%' } }, cardDataUpdate,\n  { new: true, strict: false }\n);\nconst result = await Card.findById(id);\nconsole.log(result);\n"})}),"\n",(0,t.jsx)(n.p,{children:"All properties must change:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:"{\n  cardNumber: '4321 4321 4321 4321',\n  zipCode: '43210'\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"immutable-with-strategy-throw",children:["Immutable with strategy ",(0,t.jsx)(n.code,{children:"THROW"})]}),"\n",(0,t.jsxs)(n.p,{children:["If ",(0,t.jsx)(n.code,{children:"strict"})," is set to ",(0,t.jsx)(n.code,{children:"THROW"}),", Ottoman will throw an error if you try to update ",(0,t.jsx)(n.code,{children:"cardNumber"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"await Card.findOneAndUpdate(\n  { cardNumber: { $like: '%5678 5678 5678 5678%' } }, cardDataUpdate,\n  { new: true, strict: CAST_STRATEGY.THROW }\n);\n"})}),"\n",(0,t.jsx)(n.p,{children:"will get:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:"ImmutableError: Field 'cardNumber' is immutable and current cast strategy is set to 'throw'\n"})}),"\n",(0,t.jsxs)(n.admonition,{title:"NOTE",type:"tip",children:[(0,t.jsxs)(n.p,{children:["Ottoman's immutability only applies to ",(0,t.jsx)(n.code,{children:"document"})," that have already been saved to the database."]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// Define schema\nconst CardSchema = new Schema({\n  cardNumber: { type: String, immutable: true },\n  zipCode: String,\n});\n// Create model\nconst Card = model('Card', CardSchema);\n// Create document\nconst myCard = new Card({ cardNumber: '4321 4321 4321 4321', zipCode: '43210' });\n// Document is new\nmyCard.$isNew; // true\n\n// can update the document because $isNew: true\nmyCard.cardNumber = '0000 0000 0000 0000';\nmyCard.cardNumber; // '0000 0000 0000 0000'\n\n// now let's save myCard\nconst ottoman = getDefaultInstance();\nawait ottoman.start();\n\nconst myCardSaved = await myCard.save();\n\n// after save\nmyCardSaved.cardNumber = '1111 1111 1111 1111';\nmyCardSaved.cardNumber; // '0000 0000 0000 0000', because `cardNumber` is immutable\n\n// Example with create\nconst myCard2 = await Card.create({\n  cardNumber: '4321 4321 4321 4321',\n  zipCode: '3232'\n});\nconst myCard3 = await Card.findOne(\n  { cardNumber: '4321 4321 4321 4321' }, // filters\n  { consistency: SearchConsistency.LOCAL } // options\n);\n\nmyCard2.$isNew; // false\nmyCard3.$isNew; // false\n"})})]}),"\n",(0,t.jsx)(n.h2,{id:"schema-helpful-methods",children:"Schema Helpful Methods"}),"\n",(0,t.jsxs)(n.p,{children:["Each ",(0,t.jsx)(n.code,{children:"Schema"})," instance has two helpful methods: ",(0,t.jsx)(n.code,{children:"cast"})," and ",(0,t.jsx)(n.code,{children:"validate"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"cast-method",children:"Cast Method"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"cast"})," method gets a Javascript Object as the first parameter and enforces schema types for each field in the schema definition."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const schema = new Schema({\n  name: String,\n  price: Number,\n  createdAt: Date\n})\n\nconst result = schema.cast({\n  name: 'TV',\n  price: '345.99',\n  createdAt: '2020-12-20T16:00:00.000Z'\n})\n"})}),"\n",(0,t.jsx)(n.p,{children:"Result variable now look like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:"{\n  name: 'TV',\n  price: 345.99, // price was casted to Number\n  createdAt: 2020-12-20T16:00:00.000Z //createdAt was casted to Date\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"cast-method-options",children:"Cast Method Options"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"cast"})," method have a few useful options:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"interface CastOptions {\n  strict?: boolean;\n  skip?: string[];\n  strategy?: CAST_STRATEGY;\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"strict"})," will remove fields not defined in the schema. The default value is set to true."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"skip"})," will be a string array with values of the key you may want to prevent to cast. The default value is empty []."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"strategy"})," when cast action fails, defined strategy is applied. The default strategy is set to ",(0,t.jsx)(n.code,{children:"defaultOrDrop"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Available strategies are:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"CAST_STRATEGY\n{\n  KEEP = 'keep', // will return original value\n  drop = 'DROP', // will remove the field\n  THROW = 'throw', // will throw an exception\n  DEFAULT_OR_DROP = 'defaultOrDrop', // use default or remove the field if no default was provided\n  DEFAULT_OR_KEEP = 'defaultOrKeep' // use default or return original value\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"validate-method",children:"Validate method"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"validate"})," method gets a Javascript Object as the first parameter and enforces schema types, rules, and validations for each field in the schema definition. If something fails an exception will be throw up, else the ",(0,t.jsx)(n.code,{children:"validate"})," method will return a valid object for the current Schema."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const schema = new Schema({\n  name: String,\n  price: Number,\n  createdAt: Date\n})\n\nconst result = schema.validate({\n  name: 'TV',\n  price: '345.99',\n  createdAt: '2020-12-20T16:00:00.000Z'\n})\n"})}),"\n",(0,t.jsx)(n.p,{children:"Result variable now looks like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:"{\n  name: 'TV',\n  price: 345.99, # price was casted to Number\n  createdAt: 2020-12-20T16:00:00.000Z # createdAt was casted to Date\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"validate-method-options",children:"Validate Method Options"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"validate"})," method has 1 option:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"{\n  strict: boolean; // strict set to true, will remove field not defined in the schema\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["By default, it will get the ",(0,t.jsx)(n.code,{children:"strict"})," option value set via the Schema constructor."]}),"\n",(0,t.jsx)(n.h2,{id:"extend-schemas",children:"Extend Schemas"}),"\n",(0,t.jsx)(n.h3,{id:"add-method",children:"Add Method"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"add"})," method allows adding extra fields or extending properties of other schemas."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const plane = new Schema({ name: String });\nconst boeing = new Schema({ price: Number });\nboeing.add(plane);\n\n// You can add also add fields to this schema\nboeing.add({ status: Boolean });\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"When a schema is added, the following properties are copied: fields, statics, indexes, methods, and hooks. Properties that already exist in the schema (fields, statics, indexes, methods) are overwritten by those of the added schema, except for hooks that are combined."})}),"\n",(0,t.jsx)(n.h2,{id:"next-up",children:"Next Up"}),"\n",(0,t.jsxs)(n.p,{children:["Nice, now we'll can see how ",(0,t.jsx)(n.a,{href:"/docs/basic/model",children:"Models"})," works."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},7944:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/howToUse-569a5eee66823bc4c5e4346d12eacc6f.jpg"},8453:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>r});var s=a(6540);const t={},i=s.createContext(t);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);